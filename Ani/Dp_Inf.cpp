/*
    Dp_Inf.cpp                                        /91.01.18/
                                                      /95.05.28/
   Процедура доступа к файлам батиметрии и списку постов наблюдения
  -----------------------------------------------------------------

  Обязательными исходными данными для программы  ANI должно быть
  указание на файлы цифровой батиметрии, определенной на равномерной
  прямоугольной сетке, заданной в Меркаторской или в Географической
  проекции.   Описание батиметрических данных производится в
  информационном файле с расширением (.inf), внутри которого
  делается ссылка на реальные цифровые данные, сформированные
  в текстовом (.dat), цело-численном (.int)
  или байтовом (.byt) форматах.

  Данные текстового информационного файла заполняются в соответствии
  с номером строки, в строку заносится информация содержание которой
  связывается с положением числа относительно начала строки.

     .-----------------------------------.
     ¦   Образец информационного файла   ¦
     '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
Название или назначение батиметрической карты
         в двух строках комментариев
Okhotsk.int
   2                ¦ Type        0:Text; 1:Byte; 2:Integer; 4:Float
   2                ¦ Format      0:Var;  1:Line; 2:Field; 3:Space
 144 256            ¦ Ny Nx       Field's Dimension
  12 16 62 76       ¦ Jy Jx Ly Lx Field's Base & Size
8650 -2957 m        ¦ Max Min     Bathimetry Extrema & Scale
  12 12 ' 50        ¦ Sy Sx ' Fe  Grid's Step, <'dkm> & Lat.of scale
 -18 42°36' 141°55' ¦ Cs Fi°'Lo°' Course, Latitude & Longitude
   5                ¦ Nc        Number of Marigrams (control points)
  11.5 6.2         Korsakov        46°18'  142°53'   64
  59      21       Magadan         58°60'  142°39'   52
  55:50' 162:39'   Усть Камчатск ; 31 62  комментарий в конце строки
; 22.3    50.1     Petropavlovsk --       строка исключена полностью
  52°50' 159°02'   Петропавловск Камчат^ский, в имени только 20 букв
  37      16       Okha 53°47' 143°30' 110 здесь имя из одного слова

 1-2  Две строки комментариев,
      которые являются заголовком к графическому изображению;
  3 - Имя числового файла, где описание пути доступа может быть
      опущено, если батиметрия находится в той же директории, что и
      информационный файл, также может быть опущено и само имя файла
      данных, если это имя совпадает с именем (.inf).
  4 - Тип числовых данных в файле батиметрии:
      0-текстовые(.dat); 1-байтовые(.byt) или 2-целые(.int);
  5 - Метод представления числовых данных.
      В настоящем варианте ANI здесь должно быть число 2;
  6 - Размерность (nY,nX) для полной матрицы в файле батиметрии;
  7 - Смещение и размеры вырезаемого  из батиметрии  прямоугольника.
      Первые два числа определяют нижний левый угол с которого
      начинается считывание данных, он может быть задан либо целыми
      числами - индексами матрицы, либо с указанием признака градусной
      меры с помощью символов ( °:'" ). Размеры считываемого сектора
      данных всегда задаются длинами сторон в точках;
  8 - Экстремумы (Max,Min) батиметрии и символ масштаба m,cm или dm.
      Если Max<Min, то это означает, что глубины заданы отрицательными
      числами, а береговые высоты положительными. В такой матрице
      производится автоматическое изменение знака у всего массива
      данных.
  9 - Шаг сетки dY,dX: в градусах или минутах (deg или ') для
      географической проекции,  в  метрах или километрах (m или km)
      для меркаторской. Если первое число, Dy - отрицательно, то это
      означает, что строки исходной матрицы отсчитываются сверху вниз.
      Третий символ (m,km,deg,') определяет тип проекции,
      соответственно. Последнее, 4-е число определяет приведенную
      широту для меркаторской карты.
 10 - Направление левой границы батиметрии относительно главного
      меридиана и географические координаты  для левого нижнего угла
      матрицы батиметрии (как карты). Координаты задаются  в слитном
      формате *): +ddd°mm'ss"zz или +ddd:mm'ss"zz, где  каждое поле
      может быть плавающим числом с точкой, а обычное число без
      символа окончания воспринимается как градусная величина.
 11 - Количество контрольных пунктов, координаты которых задаются в
      соответствующем количестве следующих строк.
 12+Nc - В старом формате строка описания пункта наблюдения состояла
      из индексных координат (ky,kx )  относительно  полной  матрицы
      батиметрии и одного слова названия для этого пункта.
         Новый формат описания включается если в одном из координат-
      ных чисел содержится символ градусной меры ( °:'" ), тогда ко-
      ординаты считаются географическими,  а  название собирается из
      последующих слов пока длина строки не превысит 20 символов.
         Символ точка с запятой (;) является  признаком  начала
      комментария, который может ставится также и в начале строки.
         Обычно выборка координат  пунктов  наблюдения  производится
      при старте программы ANI или при чтении  новой  батиметрии  из
      картографического редактора Chart. В этом  случае  все  пункты
      выходящие за пределы считываемого сегмента [Jy+Ly,Jx+Lx],
      исключаются из списка и не попадают в программу. При повторном
      считывании координат исключаются также  новые  точки,  которые
      приближаются на 1/3 размера ячейки к одной  из  уже  имеющихся
      точек.
         Если же считывание батиметрии производится  через  редактор
      (Chart)  вызванный  в  режиме   вычислительного   эксперимента
      (Simulation), то новые пункты наблюдения не считываются, а уже
      имеющиеся в оперативной памяти точки сохраняются без изменений
      их координат, не смотря на выход их за границы расчетной
      области.

*) В определении градусной меры
  символ (°) может заменятся двоеточием (:).

  Для запуска программы ANI желательно предварительно исполнить
  DispCCCP.com для русификации консоли (текстового экрана),
  если в комментариях информационного файла есть слова
  с Русскими буквами.

    D:\Path\>Ani [FileName.[inf]]   имя файла не обязательно

  Программа может быть исполнена один раз, для конкретного файла
  батиметрии. Это не является существенным ограничением т.к.
  новый файл может быть прочитан в режиме редактирования.
*/
#include "Depth.h"
                               //
static char Nm[MAX_PATH+4]=""; // Имя последнего открытого файла
static bool First=true;        // Признак первого чтения данных
static FILE *Fi;               // Для информационного файа
                               //
void Depth::close(){ if( Fs )fclose( Fs ); Fs=NULL; Nm[0]=0; }
void Depth::remove()
{ if( Fs ){ fclose( Fs ); Fs=NULL; if( Nm[0] )::remove( Nm ); } Nm[0]=0;
}
//
//   Открытие нового файла батиметрии с контролем перезаписи
//
char* Depth::open( char* name, const char* ext, const char* mode )
{     close();
      OemToCharBuff( name,Nm,strcut( name )+1 );
  if( strchr( name,'.' )==NULL )fext( Nm,ext );
      strcpy( Str,Nm );
  if( mode[0]=='w' )
  { char exb[4];
    strcpy( exb,ext ); exb[0]='~'; fext( Str,exb );
                               ::remove( Str );
                                 rename( Nm,Str );
  } Fs=fopen( Nm,mode ); return Str;
}
//   Формирование имени файла данных
//
void Depth::open( char regime )
{
 static char reg[3]="rt"; reg[0]=regime;
 char *s,*S=reg+2;        reg[1]='b';
  switch( Type ){ case 0: reg[1]='t';
                  case 4: S=(char*)"dat"; break;
                  case 1: S=(char*)"byt"; break;
                  case 2: S=(char*)"int";
                }            //
  s=strcpy( Str,InfName );  // Поиск признака
  if( Name[0]>=' ' )        // полного имени файла
  { if( Name[1]!=':' )      //
    if( (s=strrchr( Str,'\\'))!=NULL )s++; else s=Str;
    strcpy( s,Name );
  } fext( strcpy( Name,Str ),S );
//
//      Открытие файла данных
//
  open( Name,S,reg );
}
//
//   Выборка одного слова из строчки Str в памяти
//
static char *Sa=Str;    // Строчка со ссылкой (dscan->scan -> имя станции)
static char *scan()     //
{ char* Z;              // Sa - общая только для scan, dscan и имя станции
  if( Sa[0]==0 )Sa=Str; //
  while( Sa[0]<=' ' )if( Sa[0] )Sa++; else goto EoLn; Z=Sa;
  while( Sa[0]>' ' )Sa++;
                if( Sa[0] ){ Sa[0]=0; Sa++; } else Str[0]=0;
                return Z;
EoLn: Str[0]=0; return Str;
}
//   Выборка одной строчки из файла и стандартное сканирование
//
static char *dscan_prt;

static int dscan( const char *fmt=0,... )
{ if( !fgets( Str,sizeof( Str ),Fi ) )return Str[0]=0; strcut( Sa=Str );
  if( *dscan_prt )printf( dscan_prt,Str );
//if( First )
//{ static int y=0;
//  if( ++y>=Tv.mY/Tv.Th )y=12; Tgo( 0,y ); Tprintf( "%s    ",Str );
//}
  if( !fmt )return strcut( Str ); else
  { va_list aV;                    va_start( aV,fmt );
    int cnt=vsscanf( Str,fmt,aV ); va_end( aV );
    return cnt;
} }
static bool IsDegree( char* Msg ){ return strpbrk( Msg,"\xF8:'\"" )!=NULL; }

Depth& Depth::read( char* PathName )
//
//     Блок чтения информационного файла
//          Name   имя файла данных ( для INFO - описания )
//          Typ    тип данных: 0-Text; 1-Byte; 2-Integer...
//          Ny,Nx  полная размерность матрицы
//          Jy,Jx  начальный отсчет считываемого сегмента
//          Ly,Ly  размерность считываемого сегмента данных
//          Nc     количество мореографных точек в файле .INF
{
 Point P;
 Real Meashure=0.0;
 int  Jy,Jx=-1,                 // За границей размерности массива
      Ly,Lx,                    // По максимальной протяженности
      i,k=Nmp,nc=0;
 char Mp[11],Inv=0,             // Inv: 0x1 Изменение знака батиметрии
     *sy,*sx;                   //      0x2 Порядок считывания строк
     *Str=0;
ReOpen:
  if( !PathName ){ (PathName=InfName)[0]=0; }
       PathName=strcpy( InfName,PathName ); // [0]<=' '?"*":PathName );
//  else
//  if( restore( PathName )>0 )
//  { if( !First )              // Двойное блокирование повторного входа
//    { if( Active&0x8000 )
//      if( Fs ){ fclose( Fs ); Fs=NULL; }
//      Active&=~0x8000;
//    } return *this;
//  }
  if( PathName[0]=='*' )Fi=0; else
  { fext( PathName=strcpy( InfName,PathName ),"inf" ); Fi=fopen( InfName,"rt" );
  }
  if( Fi==NULL )
  { Tfile( InfName,"Имя описателя батиметрического файла (.inf)" );
    if( InfName[0]=='*' )exit( 0 );
    goto ReOpen;
  }
  dscan_prt=(char*)"\n%s";
  strcpy( InfName, W2D( InfName ) );
  Active&=~1; Name[0]=0;          // Гашение готовности данных
  dscan(); strcpy( Msg[0],Str );  // две строки
  dscan(); strcpy( Msg[1],Str );  // для заголовка и дополнительной надписи
  dscan(); strcpy( Name,  Str );  // имя файла данных
  dscan( "%d",&Type ); if( Type>4 || Type==3 )Break( "Valid Type 0,1,2 or 4" );
  dscan( "%d",&i );    if( i!=2 )Break( "?Bad File" );
  dscan( "%d%d",&Ny,&Nx ); //
  dscan();                       // Разбор способа задания базисного угла
  sy=scan(); Jy=0x7FFFFFFF;      //
  sx=scan(); Ly=atoi( scan() );  // if( Ly<=0 || Ly>Ny )Ly=Ny;
             Lx=atoi( scan() );  // if( Lx<=0 || Lx>Nx )Lx=Nx;
  if( IsDegree( sy ) || IsDegree( sx ) ){ AtoD( sy,P.y ); AtoD( sx,P.x ); }
                                   else { Jy=atoi( sy ); Jx=atoi( sx ); }
  dscan( "%lf%lf%s",&Max,&Min,Mp );
  switch( *Mp|0x20 ){ case 'c': Meashure=0.01; break;
                      case 'd': Meashure=0.10; }
  dscan( "%lf%lf%s%lf",&Sy,&Sx,Mp,&Fe );
  dscan(); AtoD( AtoD( AtoD( Str,Cs ),Base.y ),Base.x );
                       Fe /= Radian;
                       Base/=Radian;
  if(*Mp=='\xF8')*Mp='d'; Ms=*Mp|0x20;
  if( Sy<0.0 ){ Inv|=2; Sy=-Sy; }              // Для строк задом-наперед
  { Real s=scale(); Sy*=s; Sx*=s; }
          basis();               // Здесь подготовлен базис для всей батиметрии
  if( Jy==0x7FFFFFFF )
  { DtI( P ); Jy=(int)P.y; if( Jy<0 )Jy=0; // Пересчет координат в
              Jx=(int)P.x; if( Jx<0 )Jx=0; // индексы от полной матрицы
  }
#if 0
  if( Jy+Ly>Net.y )Ly=My-Jy; if( Ly<=0 )Jy=0,Ly=My; // Блокировка
  if( Jx+Lx>Net.x )Lx=Mx-Jx; if( Lx<=0 )Jx=0,Lx=Mx; // нарушения границ
#endif
  if( !Ly )Ly=Ny-Jy;
  if( !Lx )Lx=Nx-Jx;
  if( Jy+Ly>Ny )Ly=Ny-Jy;            // Блокировка нарушения
  if( Jx+Lx>Nx )Lx=Nx-Jx;            // границ (всякий случай)
//if( Ly<=0 )Jy=0,Ly=My;
//if( Lx<=0 )Jx=0,Lx=Mx;
  if( Max<Min  )Inv|=1;                    // Изменение знака при считывании
  if( Jy || Jx || Ly!=Ny || Lx!=Nx ) // Для выбора новых экстремумов
      Max=Min=0;                           //
  P.y=Jy;                 //
  P.x=Jx; ItD( P );       // Определение нового базиса с учетом сегмента
     Base.y=P.y/Radian;   //
     Base.x=P.x/Radian; basis();
//
//      чтение мореографных данных с учетом сформированного
//              описания картографической проекции.
//
  if( !(Active&as_Simula) ) // Только если без численного моделирования
  { dscan( "%d",&nc );
    if( nc>0 )
    { const int np=nc/64+1;             // делитель консольного вывода < 64 раз
      M=(MARIO*)Allocate( (nc+=(k=Nmp))*sizeof( MARIO ),M );
      for( int kfm=k; kfm<nc && dscan(); ) // Выборка координат для всех
      {     sy=scan();                     // новых пунктов наблюдения
            sx=scan(); dscan_prt="";       // с очисткой консольной строки
        if( sy[0] && strchr( "+0123456789-.",sy[0] ) )
        if( sx[0] && strchr( "+0123456789-.",sx[0] ) )
        {                              //
         MARIO& Mk=M[k];               // Временное выделение блока
          AtoD( sy,Mk.G.y ); ++kfm;    // для новой мореографной точки
          AtoD( sx,Mk.G.x );           //
          if( IsDegree( sy ) || IsDegree( sx ) )DtI( Mk.G ); else
            { Mk.G.y-=Jy;                //
              Mk.G.x-=Jx;                //
            } i=-1;                      // Проверка на попадание в границы
          if( Mk.G.y>0 && Mk.G.y<Ly-1 )  // расчетной батиметрии
          if( Mk.G.x>0 && Mk.G.x<Lx-1 )  // (береговые точки - остаются)
          for( i=0; i<k; i++ )           // и сверка на сближенность
            { DtI( P=M[i].G );           // -- в 30% по шагу сетки.
              if( abs( P-Mk.G )<0.3 )break;
            }        //
          if( i==k ) // !!! именно здесь сдвигается индекс главного цикла 'k'
          { ItD( Mk.G );                       // <240>+ ЁёЄєЇїЎў°•·v№¤¦
            while( *Sa!=0 && *Sa<=' ' )Sa++;   // Название пункта | '·'
            if( !Sa[0] || Sa[0]==';' )Mk.cp=strdup( "·" ); else
            { if( strchr( Sa,';' ) )strchr( Sa,';' )[0]=0;
              if( strcut( Sa )>20 )Sa[20]=0; strcut( Sa );
              Mk.cp=strdup( Sa );               // Не закрываем разбор строки
            } k++;                              // и переходим к другому пункту
            if( !(k%np) )dscan_prt="\r%s ";     // Прореженный перебор записей
      } } } Nmp=k;       dscan_prt="\n%s ";     // на стартовой консоли
      if( Nmp<nc )M=(MARIO*)Allocate( Nmp*sizeof( MARIO ),M );
  } } fclose( Fi );
//
//      Чтение заданного сектора файла
//
      open( 'r' );
  if( Fs==NULL )Break( "\r\n%s not open",Name );
  {
   float *R; Real Wd=0.0;
   int y,ky,
       x,kx=0; if( Inv&1 )Max=-Max,Min=-Min;
      allocate( Ly,Lx );
    R=(float*)Allocate( Type ? Type*Lx : Nx*sizeof( float ) );

    if( Inv&2 )Jy=Ny-Jy-Ly;
    if( !Type )ky=0;
         else  ky=Jy;
    for( y=0; y<Ly && ky<Ny; ky++ )
    { if( Type>0 )
      { fseeko64( Fs,Type*( (long long)Nx*ky+Jx ),SEEK_SET ); kx=0;
        fread( R,Lx,Type,Fs );
      } else
      for( x=0; x<Nx; x++ ){ fscanf( Fs,"%f",R+x ); kx=Jx; }
      if( ky>=Jy )
      { for( x=0; x<Lx && kx<Nx; kx++,x++ )
        { switch( Type )
          { case 0:
            case 4: Wd=R[kx];            break;
            case 2: Wd=((short*)R)[kx];  break;
            case 1: Wd=((unsigned char*)R)[kx];
          }
          if( Inv&1    )Wd=-Wd;
          if( Meashure )Wd*=Meashure;
          if( Max<Wd   )Max=Wd;
          if( Min>Wd   )Min=Wd; __Depth[y][x]=Wd;
        } ++y;
    } }
    //
    //  c выявлением возможности замыкания параллелей
    //
    Active|=1; is_Globus(); Map.Jx=Map.Jy=0.0;
    Allocate( 0,R );        Map.Ly=Map.My=Ny=Ly;
    close();                Map.Lx=Map.Mx=Nx=Lx;
    if( Inv&2 )for( y=0; y<Ny/2; y++ )          // Обратная перестановка строк
    { R=__Depth[y]; __Depth[y]=__Depth[Ny-y-1]; __Depth[Ny-y-1]=R;
  } }
  if( !(Active&0x18) )Map.window(); // окно, если вызов не из редактора карт
  //
  // Поиск ближайших береговых точек для всех контрольных постов
  //
  for( k=0; k<Nmp; k++ )find_coast( M[k] );
  First=false;          printf( "\n\n" );
  return *this;
}
