//
//                 -= T I D E R =-
//
//              Предвычисление приливов        ИМГиГ ДВО АН CCCР
//
//              Математика    Рабинович А.Б.
//              Трансляция C++ Храмушин В.Н. { 1993-January }
/*г-------------------------------------------------------------¬
                                                                ¦
                О С Н О В Н Ы Е   Г А Р М О Н И К И     (°/h)   ¦
   номера, частоты, 3-х значные индексы и средние коэффициенты  ¦
                                                                ¦
  1   SA   0.041069  001 .0116 ¦ 17  FI1  15.123206   112 .0042 ¦
  2  SSA   0.082137  002 .0727 ¦ 18 TET1  15.512590  12-2 .0057 ¦
  3   MM   0.544375  010 .0825 ¦ 19   J1  15.585443   120 .0296 ¦
  4   MF   1.098033  020 .1564 ¦ 20  OO1  16.139102   130 .0162 ¦
  5  2Q1  12.854286 1-30 .0096 ¦ 21  2N2  27.895355  2-20 .0230 ¦
  6 SIG1  12.927140 1-32 .0115 ¦ 22  MU2  27.968208  2-22 .0277 ¦
  7   Q1  13.398661 1-20 .0721 ¦ 23   N2  28.439729  2-10 .1739 ¦
  8  RO1  13.471515 1-22 .0137 ¦ 24  NU2  28.512583  2-12 .0330 ¦
  9   O1  13.943036 1-10 .3769 ¦ 25   M2  28.984104   200 .9081 ¦
 10   M1  14.492052  100 .0296 ¦ 26  LD2  29.455625  21-2 .0067 ¦
 11  HI1  14.569548  102 .0057 ¦ 27   L2  29.528479   210 .0257 ¦
 12  PI1  14.917865 11-3 .0103 ¦ 28   T2  29.958933  22-3 .0248 ¦
 13   P1  14.958931 11-2 .1755 ¦ 29   S2  30.        22-2 .4225 ¦
 14   S1  15.       11-1   --  ¦ 30   R2  30.041067  22-1 .0035 ¦
 15   K1  15.041069  110 .5301 ¦ 31   K2  30.082137   220 .1150 ¦
 16 PSI1  15.082135  111 .0042 ¦ 32   M3  43.476156   300 .0119 ¦
                               ¦ 33   S3  45.        33-3   --  ¦
                                                                ¦
            Н Е Л И Н Е Й Н Ы Е   Г А Р М О Н И К И             ¦
                                                                ¦
 34  MSF   1.015896  ¦ 45  SO3  43.943036  ¦ 56   M6  86.952313 ¦
 35  MP1  14.025173  ¦ 46  MK3  44.025173  ¦ 57 MSN6  87.423834 ¦
 36  SO1  16.056964  ¦ 47  SK3  45.041069  ¦ 58 2MS6  87.968208 ¦
 37  OQ2  27.341696  ¦ 48  MN4  57.423834  ¦ 59 2MK6  88.050346 ¦
 38 MNS2  27.423834  ¦ 49   M4  57.968208  ¦ 60 2SM6  88.984104 ¦
 39  OP2  28.901967  ¦ 50  SN4  58.439729  ¦ 61 MSK6  89.066241 ¦
 40 MKS2  29.066242  ¦ 51  MS4  58.984104  ¦ 62   M8 115.936417 ¦
 41 MSN2  30.544375  ¦ 52  MK4  59.066242  ¦ 63   S5  75.       ¦
 42  KJ2  30.626512  ¦ 53   S4  60.        ¦ 64   S6  90.       ¦
 43 2SM2  31.015896  ¦ 54  SK4  60.082137  ¦ 65   S7 105.       ¦
 44  MO3  42.927140  ¦ 55 2MN6  86.407938  ¦ 66   S8 120.       ¦
                     ¦                     ¦ 67   S9 135.       ¦
 г-------------------+---------------------+---------------------
 ¦
 ¦              Соотношения между гармониками
 ¦
 ¦       N2/M2 - .1914     Q1/O1 - .1914    K2/S2 - .2721
 ¦       T2/S2 - .0586     R2/S2 - .0084   NU2/N2 - .1899
 ¦      LB2/L2 - .2606    2N2/MU2- .8284    P1/K1 - .3310
 ¦      PI1/K1 - .0194   PSI1/K1 - .0080   FI1/K1 - .0142
 ¦      HI1/M1 - .1913    2Q1/SG1- .8283   RO1/Q1 - .1899
--                       TET1/J1 - .1914
*/
#include <Math.h>
#include "Tide.h"
                 //
double           // Массив угловых скоростей (deg/hour)
 Tidal_Quad[67]= //
 {  0.0410686,  0.0821373, 0.5443747, 1.0980331,12.8542862,12.9271398,
   13.3986609, 13.4715145,13.9430356,14.4920521,14.5695476,14.9178647,
   14.9589314, 15,        15.0410686,15.0821353,15.1232059,15.5125897,
   15.5854433, 16.1391017,27.8953548,27.9682084,28.4397295,28.5125831,
   28.9841042, 29.4556253,29.5284789,29.9589333,30,        30.0410667,
   30.0821373, 43.4761563,45,         1.0158958,14.0251729,16.0569644,
   27.3416964, 27.4238337,28.9019669,29.0662415,30.5443747,30.6265120,
   31.0158958, 42.9271398,43.9430356,44.0251729,45.0410686,57.4238337,
   57.9682084, 58.4397295,58.9841042,59.0662415,60,        60.0821373,
   86.4079380, 86.9523127,87.4238337,87.9682084,88.0503457,88.9841042,
   89.0662415,115.9364170,   75, 90, 105, 120, 135
 };
static const double IR=M_PI/180.0,
                    JR=M_PI/90.0;
static double B[134];   // Массив астрономических поправок
                        //
//----------------------------------------------------------------
//      Функция D360 приводит градусные величины в диапазон 0-360
//
inline double D360( double P ){ return P-floor( P/360 )*360; }
//
//----------------------------------------------------------------
//      Расчет астрономических параметров
//      F и U   рассчитываются на середину интервала наблюдений
//      V0      на начало
//
static void ASTR        //
(      long Day,        // Дата
     double Time,       //  и время начала наблюдений
        int N,          // Длина подготавливаемого ряда
     double DL          // Шаг во времени для выходного ряда
){                      //   B(134) - рассчитываемый массив
 static const double    // ( B(2*I)-F,B(2*I-1)-V0+U )
  UF0[4][8]=            //
  { {1.0000,1.0429,1.0089,1.0060,1.0129,1.1027,1.0004,1.0241 }
  , {-.1300, .4135, .1871, .1150, .1676, .6504,-.0373, .2863 }
  , { .0013,-.0040,-.0147,-.0088,-.0170, .0317, .0002, .0083 }
  , { .0000, .0000, .0014, .0006, .0016,-.0014, .0000,-.0015 } },
  UF1[3][8]=
  { { 0.00,-23.74,10.80,-8.86,-12.94,-36.68,-2.14,-17.74 }
  , { 0.00,  2.68,-1.34, 0.68,  1.34,  4.02, 0.00,  0.68 }
  , { 0.00, -0.38, 0.19,-0.07, -0.19, -0.57, 0.00, -0.04 } };
 static const int
  I0[8]={ 2,3,8,14,18,19,24,30 },
  IV[4][33]=
  { {   0,  0,  1,  2, -4, -4, -3, -3, -2, -1, -1,  0,  0,  0,  0,  0
  ,  0, 1,  1,  2, -4, -4, -3, -3, -2, -1, -1,  0,  0,  0,  0, -3,  0 }
  , {   1,  2,  0,  0,  1,  3,  1,  3,  1,  1,  3, -2, -1,  0,  1,  2
  ,  3,-1,  1,  1,  2,  4,  2,  4,  2,  0,  2, -1,  0,  1,  2,  3,  0 }
  , {   0,  0, -1,  0,  2,  0,  1, -1,  0,  0, -1,  0,  0,  0,  0,  0
  ,  0, 1, -1,  0,  2,  0,  1, -1,  0,  1, -1,  0,  0,  0,  0,  0,  0 }
  , {   0,  0,  0,  0,270,270,270,270,270, 90, 90,192,270,180, 90,168
  , 90,90, 90, 90,  0,  0,  0,  0,  0,180,180,282,  0,258,  0,180,180 }
  };
 int  E,D,G,i,j;
 double *F0=B+68,*U0=B+101, U,V,
        SS,     // Лунная долгота
        HH,     // Солнечная долгота
        PP,P1,  // Долгота Лунного перигея
        AN,N1;  // Долгота Солнечного перигея
                //
  for( i=0; i<33; i++ )F0[i]=1,U0[i]=0;
//
//----------------------------------------------------------------
//      Астрономические параметры S,H,P,N на дату G,E,D 00.00 GMT
//
             julday( Day,E,D,G );
  D=int( Day-julday( 1,1,G ) );
  U = G-1900;
  V =(G-1901)/4+D;
  SS=D360( 277.025+129.38481*U+13.1764*V );
  HH=D360( 280.19 -  0.23872*U+0.98565*V );
  PP=D360( 334.385+ 40.66249*U+0.11140*V );
  AN=D360( 259.157- 19.32818*U-0.05295*V );
//
//----------------------------------------------------------------
//      Поправки во времени на середину расчетного интервала
//
  N1=floor( ((N-1)*DL+Time)/48.0 );
  P1=D360( PP+N1*0.11140 )*JR;
  N1=D360( AN-N1*0.05295 )*IR;
//
//----------------------------------------------------------------
//      Расчет параметров основных гармоник (на начало суток)
//
  for( i=0; i<8; i++ ){ U =0.0;
                        V =UF0[0][i];
    for( j=1; j<4; j++ )V+=UF0[j][i] * cos( j*N1 ),
                        U+=UF1[j-1][i]*sin( j*N1 );
         j=I0[i]; U0[j]=U;
                  F0[j]=V;
  }
  U=1-.2505*cos(P1)-.1102*cos(P1-N1)-.0156*cos(P1-N1*2)-.0370*cos(N1);
  V= -.2505*sin(P1)-.1102*sin(P1-N1)-.0156*sin(P1-N1*2)-.0370*sin(N1);
  F0[26]=hypot( V,U );
  U0[26]=atan2( V,U )/IR;
  P1/=2;
  U = 2*cos( P1 )+0.4*cos( P1-N1 );
  V =   sin( P1 )+0.2*sin( P1-N1 );
  F0[9]= hypot(V,U);    F0[31]= pow( F0[24],1.5 );
  U0[9]= atan2(V,U)/IR; U0[31]= 1.5*U0[24];
                        F0[10]= F0[17]=F0[18];
                        U0[10]= U0[17]=U0[18];
  for( i=4;  i<8;  i++ )F0[i] = F0[8], U0[i]=U0[8];
  for( i=20; i<26; i++ )F0[i] = F0[24],U0[i]=U0[24];
  for( i=0;  i<33; i++ )
  B[i*2+1]=F0[i],
  B[i*2] = U0[i]+SS*IV[0][i]+HH*IV[1][i]+PP*IV[2][i]+IV[3][i];
//
//----------------------------------------------------------------
//        Расчет параметров нелинейных гармоник
//
  for( i=66; i<122; i+=2 )B[i+1]=B[49],B[i]=B[48];
  B[66]=B[84]=-B[48];
  B[70]=      -B[16];
  B[71]=B[17];
  B[72]=B[16]+B[12]; B[74]+=B[44];
  B[73]=B[17]*B[13]; B[75]*=B[45];
  B[76]=B[16]+B[24]; B[78]+=B[60];
  B[77]=B[17]*B[25]; B[79]*=B[61];
                     B[80]-=B[44];
                     B[81]*=B[45];
  B[82]=B[28]+B[36]; B[86]+=B[88]=B[16];
  B[83]=B[29]*B[37]; B[87]*=B[89]=B[17];
  B[96]*=2;          B[90]+=B[92]=B[28];
  B[97]*=B[97];      B[91]*=B[93]=B[29];
  B[104]=B[56]*2;    B[94]+=B[98]=B[44]; B[102]+=B[106]=B[60];
  B[105]=1;          B[95]*=B[99]=B[45]; B[103]*=B[107]=B[61];
  B[108]=B[96]+B[44];
  B[109]=B[97]*B[45];
  B[110]=B[96]+B[48];
  B[111]=B[97]*B[49];
  B[112]=B[48]+B[44];      B[114]=B[96];
  B[113]=B[49]*B[45];      B[115]=B[97];
  B[116]=B[96]+B[60];
  B[117]=B[97]*B[61];
  B[120]=B[48]+B[60];      B[122]=B[96]*2;
  B[121]=B[49]*B[61];      B[123]=B[97]*B[97];
  for( i=124; i<134; i+=2 )B[i+1]=1,
                           B[i]=0;
//      Введение поправок на часы и минуты
//
  for( i=0; i<67; i++ )B[i*2]=D360( B[i*2]+Tidal_Quad[i]*Time );
}
//----------------------------------------------------------------
//      Расчет прилива по известным гармоникам
//
static void TIDE //
( Real *Y,       // Рассчитываемый ряд
   int  N,       // Длина ряда
   int  L,       // Число волн - L*2+1 - гармонических к-тов
  Real *Q,       // Массив частот (В Рад/на интервал дискр-ти)
  Real *C        // Массив входных гармонических коэффициентов
){               //
  Real U[67],V[67],P[67],S; int i,j;
  for( S=C[0],i=0; i<L; i++ )
  { P[i]=U[i]=cos(Q[i]);
    Q[i]=V[i]=sin(Q[i]); S+=C[2*i+1];
  }
  for(   Y[0]=S,j=1; j<N; j++ )
  { for( S=C[0],i=0; i<L; i++ )
    { Real T1=P[i],
           T2=Q[i]; S+=T1*C[i*2+1]+T2*C[i*2+2]; P[i]=T1*U[i]-T2*V[i];
                                                Q[i]=T2*U[i]+T1*V[i];
    } Y[j]=S;
  }
}
#include "..\Graphics\Tv_Graph.h"
                                 //
Field Tide_Map={ 139,42,21,11 }, // Map изменяется в World_Map
      Tide_Plc={ 139,42,21,11 }; // Plc текущее активное поле
                                 //
Tide   *List_of_Tide=0; // Список приливных записей
Tide   *Current_Tide=0; // Текущий указатель приливного описателя
Real    Time_Zone = 10; // Часовой пояс для Южно-Сахалинска (+1+1 летний)
 int    Number_Tides=0; // Количество определенных мореографов
                        //
//----------------------------------------------------------------
//      Функция контроля готовности гармонических постоянных
//inline
//short CurTi(){ return Current_Tide!=0 && Current_Tide->L>0; }
//
//---------------------------------------
//      Построение приливного ряда
//
int Tide::TideSeries      //
( Real *Y, int N,         // Выходной ряд и его длина
  Real Dt,                // Шаг во времени для выходного ряда
  long Day,               // Юлианская дата
  Real Time               // Время начала процесса в часах
)                         //
{ int i,k;
  Real B1[135+1],SS[67+1],S,Z;
    memset( B1,0,sizeof( B1 ) );
//  B1[0]=Ms.Co; -- без среднего уровня
//----------------------------------------------------------------
//      Расчет астрономических поправок
//
        Time-=Time_Zone;
    if( Time<0.0  ){ Time+=24.0; --Day; } else
    if( Time>24.0 ){ Time-=24.0; Day++; }
    ASTR( Day,Time,N,Dt );
    for( i=0; i<Len; i++ )
    if( (H[i]&0x80)==0 )
    { SS[i]=Tidal_Quad[k=H[i]-1]*Dt*IR; S= C[i*2+1]*B[k*2+1];
                                        Z=(C[i*2+2]-B[k*2])*IR;
      B1[i*2+1]=S*cos( Z );
      B1[i*2+2]=S*sin( Z );
    }
//----------------------------------------------------------------
//      Восстановление прилива
//
    TIDE( Y,N,Len,SS,B1 ); return N;
}
//----------------------------------------------------------------
//      Функция возвращает значение уровня моря
//
Real Tide::TidePoint( long Day, Real Time )
{ Real T=Time; return TideSeries( &T,1,1.0,Day,Time )<0 ? 0.0:T;
}
//----------------------------------------------------------------
//      Считывание списка данных по Мореографам
//
bool Mario_Title( char* Msg )
{ if( memcmp( FTitle,Msg,6 ) )
  { Tv_bell(); Thelp( ">Неверный заголовок приливного архива." ); Tv_getc();
    return false;
  } return true;
}
int TideFileRead( const char *Fp )
{ Tide M;
  char Fnm[MAX_PATH],Msg[6],*mTF=Tfile_Filter;
  FILE *F;
  Tfile_Filter=(char*)( "Tidal Garmonics Filelist (*.tim)\0*.tim\0"
                              "All Files (*.*)\0*.*\0" );
  if( Fp )scpy( Fnm,Fp ); else fext( strcpy( Fnm,_av_[0] ),"tim" );
  if( (F=Topen( Fnm,"rb","tim","Чтение списков приливных гармонических постоянных" ))!=0 )
  { fread( Msg,1,6,F );
    if( Mario_Title( Msg ) )
    { if( Number_Tides>0 )for(;;)
      { Thelp( "<Enter>Взять новый список  <Tab>Добавить данные к существующему в памяти списку " );
        switch( Tv_getc() )
        { case _Enter: TideDataClose();
          case _Tab: goto Rd;
          case _Esc: goto Br; default:;
      } }
  Rd: Time_Zone  =Real( get2( F ) )/10.0;
      Tide_Map.Jy=Real( get2( F ) )/10.0;
      Tide_Map.Jx=Real( get2( F ) )/10.0;
      Tide_Map.Ly=Real( get2( F ) )/10.0;
      Tide_Map.Lx=Real( get2( F ) )/10.0; Tide_Plc=Tide_Map;
      for( ;; )
      { M.Len=get2( F ); if( feof( F ) )break;
        if( fread( M.Name,1,20,F )!=20 )break;
            M.Day=getw( F );    // Юлианская дата
            M.Fi=getf( F );     //
            M.La=getf( F );     // Географические координаты в градусах
            M.Co=getf( F );     // Средний уровень моря (ТНГ)
            M.Ch=getf( F );     // Критический уровень моря
            M.Cs=getf( F );     // Коэффициент пересчета на высоту цунами
            M.sW=get2( F );     // Слово признаков - старая запись 16 бит
            M.H=NULL;           //
            M.C=NULL;
            M.allocate( M.Len );
        if( M.Len>0 )
        { fread( M.H,1,M.Len,F );
          for( int i=0; i<=M.Len*2; i++ )M.C[i]=getf( F );
        }
        else getw( F );         // 4 байта являются наследием старой ошибки

        (List_of_Tide=(Tide*)Allocate((Number_Tides+1)*sizeof(Tide),List_of_Tide))[Number_Tides]=M;
        ++Number_Tides;
      }
    } Br: fclose( F );
  }   Tfile_Filter=mTF; return Number_Tides;
}
//----------------------------------------------------------------
//      Процедура выборки географических координат
//
Point TideGeo( int k )
{ static Point Geo; Geo.y=List_of_Tide[k].Fi;
                    Geo.x=List_of_Tide[k].La; return Geo;
}
//----------------------------------------------------------------
//    Распределение памяти для нового блока гармоник
//
void Tide::allocate( size_t l )
{ H=(char*)Allocate( l,H );
  C=(Real*)Allocate( (l*2+1)*sizeof(Real),C ); Len=l;
}
void Tide::free()
{ H = (char*)Allocate( 0,H );
  C = (Real*)Allocate( 0,C ); Len=0;
}
//----------------------------------------------------------------
//      Процедура выборки информации для программы Mario
//
void TideMario         //
( char* Ident,         // Название пункта наблюдения
  Real& Lon,           // Географическая долгота
  Real& Lat,           //  и широта
  Real& Mid )          // Средний многолетний уровень моря
{ *Ident=0; Lon=Lat=0; //
  if( Current_Tide ){ scpy( Ident,Current_Tide->Name,20 );
                            Lon = Current_Tide->La;
                            Lat = Current_Tide->Fi;
                            Mid = Current_Tide->Co; }
}
//----------------------------------------------------------------
//  Установка текущего мариографа по номеру в списке
//
int TideDefault( int k )
{ if( unsigned( k )>=unsigned( Number_Tides ) )return -1;
  Current_Tide = List_of_Tide+k;
  return Number_Tides;
}
//----------------------------------------------------------------
//  Установка текущего мариографа по имени мариографной станции
//
int TideDefault( const char* Name )
{ for( int k=0; k<Number_Tides; k++ )
  { if( !strncmp( Name,List_of_Tide[k].Name,20 ) )
    { Current_Tide=List_of_Tide+k; return Number_Tides;
  } } return -1;
}
//----------------------------------------------------------------
//      Процедура расчистки приливной база данных в памяти
//
void TideDataClose()
{ if( Number_Tides>0 )
  { while( Number_Tides>0 )List_of_Tide[--Number_Tides].free();
    Allocate( 0,List_of_Tide );
  } Current_Tide=List_of_Tide=NULL;
}
