//
//       Long_Waves_Initial.cpp                                     /90.11.08/
//       .-------------------------------------------------------.
//       ¦      Реализуется задание начальных условий в форме    ¦
//       ¦       геометрического очага произвольной формы        ¦
//       ¦        или определением периода входящей волны        ¦
//       °-------------------------------------------------------°
#include "..\Ani\LongWave.h"
#include "..\Ani\Tide.h"
//
//    Построение начальной волны в расчетной области (очага)
//      WTYPE = 0 - Модулированная поверхность Гауссова распределения
//              1 - Пакет синусоидальных волн с двумерным дроблением
//      ( w ) - Алгоритмы согласованы с процедурой T_HBound.
//
Real TWave::Wave( bool WTYPE, Real y, Real x )
{ Point l={ x,y };
        l=Ve.Goint( l );
  if( WTYPE )
    { if( l.y<1&&l.y>1-Vk*2 )return Va*cos( l.y*M_PI_2 )*cos( l.x*M_PI_2 );
    } else
    { if( (y=abs( l ))<6 )return Va*cos( y*Vk/2.0 )*exp( -2.0*y*y );
    }                     return 0.0;
}
//  Конструкторы в выгружаемой на оверлеях процедуре
//______
       //! WaveIs:      1 ¦ Задан период входящей волны
        //              2 ¦ Отслеживается протяженность граничной волны
        //              4 ¦ Учет геопотенциала
        //              8 ¦ На входе стохастический процесс Wt+Rand( Wk );
        //           1.00 ¦ Spherical Earth    \ .
        //           2.00 ¦ Coriolis  Forces    \ Дополнительные
        //           4.00 ¦ Viscosity Friction  / элементы вычислений
        //           8.00 ¦ Atmosphere Cyclone /
        //          10.00 - Признак запуска процесса записи мореограмм
        //!         20.00 - Признак слияния боковых границ (Земная сфера)
        // VideoM:      1 - Время на экране в абсолютных отсчетах
        //              2 - Изображение только что обновлено
        //              4 - Вывод (или нет) изолиний уровня
        //              8 - свето-теневая закраска уровней моря
        //             xC = 8+4 - свето-теневая раскраска + контуры уровней
        //             10 - Берег изображается контуром или закраской
        //             20 - Вывод потоков течения, иначе скоростей
        //             40 - 3d-style укрытые или обычные горизонтальные профили
        //           1.00 - Активизация меню Service
        //          20.00 - Прорисовка уровней в Mario-точках
        //          40.00 - Подпись времен и экстремальных величин
        // Active
        // 0x0001 Готовность батиметрии
        // 0x0006 Empty, Letters, Numbers, Identify (4) для Mario
        // 0x0020 Произведен сдвиг карты в F4 (сброс при считывании)
        // 0x0018 Был считан новый файл в F4  (сброс с перерисовкой)
        //    - 8 = 0 - Произведена перерисовка внутри программы F4
        // 0x0100 Признак замыкания параллелей -> Chart.globus() --
        // 0x1000 Признак активизации численного моделирования
        // 0x8000 Процесс восстановления сохраненного расчета
        //
void TWave::Start()
{ //static bool First=true;     // Третья блокировка рестарта
        Dp=             // Рабочая копия батиметрического массива   [метр+]
        Hg=             // Превышение уровня моря                    [метр]
        Uy=Ux=NULL;     // Поток возмущенной жидкости U = H•V        [m¤/c]
       _Fc=_Fs=NULL;    // Широта для поправки cos(Fo)/cos(F)         [рад]
       _La=NULL;        // Долгота астрономии с ЗП поправкой          [рад]
        Fa=NULL;        // Поле атмосферного давления                [метр]
        Hf=NULL;        // Поле геопотенциала заполняется в Espaso
       mxH=mnH=         // Экстремальные уровни в точках Mg          [метр]
       mFl=aFl=         // Максимальный поток и его направление
       wTm=mTm=NULL;    // Время начала регистрации, экстремум волны
        Mg=NULL;        // Вектор координат точек наблюдения
        Ma=NULL; Na=0;  // Список базисных точек маршрута циклона

//  if( First && (Active&0x8000) ){ restore(); First=false; return; }
    Sun=Moon=0.0;         //
//  if( First )           // Запрос на подготовку вычислительного эксперимента
//  {   First=false;      //       который блокируется при перечитывании данных
    Instant=Event( 0 );   // Без даты и времени - признак неготовности расчетов
    Kvs=0.0025;           // Коэффициент придонного трения
    Ta=1.0,               // Амплитудный коэффициент для всех гармоник
    To=0.0;               // Смещение фазы от начала процесса в секундах
    St=1.0/60.0;          // Заданный интервал до нового изображения
    Rt=-0.1;              // Интервал для точек рестарта в часах
    WaveAs=0;             // режимы, граничные условия (сферичность Земли 0x100)
    VideoM=0xE045;        // быстрая графика с профилями волн в местном времени
//  VideoM=0xE07C;        // рисунок в EGraph в отраженных лучах света
//  }
    Tk=-1;                // номер станции в приливных граничных условиях
    Dv=-5.0;              // глубина для представления уровня моря [m]
    Kt=0;                 // контрольный индекс шагов во времени
    Mag=-8.0;             // магнитуда - знак правится на первом обращении
    Glide=0.0;            // уклон дна под очагом цунами
    Tlaps=W0=V0=0.0;      // отсчеты времени для эксперимента и его возмущений
    New_Initial();        // Первая подготовка расчетных данных и полей
    Active|=as_Simula;    // Признак активизации численного моделирования
}
//  Подготовка всего комплекса исходных данных для вычислительного эксперимента
//      - рабочая батиметрия пересоздаётся каждый раз заново
//      - под текущие параметры численного моделирования
//
void TWave::New_Initial()  // приведение размерностей и нового массива глубин
{ Thelp( "Wait please" ); //
  Chart.edits( true );   // автоматический привод карты к меркаторской проекции
 Real cFe=cos( Chart.Fe )*Mile*Radian*60.0;     // радиан -> меркаторские метры
  Dy=cFe*Chart.Sy; Mx=Chart.Nx;       // расчетный шаг сетки устанавливается по
  Dx=cFe*Chart.Sx; My=Chart.Ny;       // приведенной широте меркаторской карты
  if( Dp )Allocate( 0,0,Dp );                  // новый, так новый и чистенький
  Dp=(Real**)Allocate( My,Mx*sizeof( Real ) ); // массив для батиметрии [м]
#pragma omp parallel for
  for( int y=0; y<My; y++ )
  for( int x=0; x<Mx; x++ )Dp[y][x]=Chart[y][x]; //! ++ сфера поправок
  if( !Hg )                                      // первое обращение к памяти
  { Hg=(Real**)Allocate( My,Mx*sizeof(Real) );   // превышение уровня моря  [м]
    Uy=(Real**)Allocate( My,Mx*sizeof(Real) );   // поток возмущенной жидкости
    Ux=(Real**)Allocate( My,Mx*sizeof(Real) );   //    U = H•V           [m¤/c]
  } Mg=Chart.M;                                  //! от этих надо бы отказаться
    Nmp=Chart.Nmp; // Прибрежная глубина очищается при инициализации до 1 метра
    DZ=0.99999;    //                   на всякий случай, ... хотя бы один метр
  if( Dy<=1e3 || Dx<=1e3 )WaveAs|=0x400;       // < 1 км. -> придонное трение
  if( hypot( Dy*My,Dx*Mx )>1e6 )WaveAs|=0x100; // тыс.км. -> сферическая Земля
    Time_Step();                               //! счетный шаг/интервал времени
  if( !(Active&as_Simula) )                    // При первой инициализации:
  { Wc=Vc=-45; Vo.y=Dy*My/2.0; Vs.x=Vo.y/2;    // параметры очага (Vo,Vs)
    Wa=Va=0;   Vo.x=Dx*Mx/2.0; Vs.y=Vo.x/3;    // измеряются в метрах от базиса
    Wo.y=Wo.x=0.0; Wk=1; Vk=2; Vt=43200.0;     // ~= 12 минут
    Ws.y=Ws.x=min( My,Mx )/6; Wt=ceil( Tstep/60.0 )*1440.0;
  } else
  { Chart.DtI( Vo ); Vo.y*=Dy; Vo.x*=Dx;  // перерасчет старых очагов
    Chart.DtI( Wo ); Wo.y*=Dy; Wo.x*=Dx;  // относительно новой расчетной сетки
  }
  Ve.Euler( Vo,Vc-Chart.Cs,Vs );          // с пропорциями по всей акватории
  We.Euler( Wo,Wc-Chart.Cs,Ws );
  for( int x=0; x<Number_Tides; x++ )  // Приливные станции в расчетной области
  { Point G=TideGeo( x ); Chart.DtI( G ); // географические координаты -> узлы
    if( G.y>-0.5 && G.y+0.5<My
     && G.x>-0.5 && G.x+0.5<Mx ){         List_of_Tide[x].sW&=~0x8001;
      if( Chart[int(G.y)][int(G.x)]<=0.0 )List_of_Tide[x].sW|= 0x0001;
    } else                                List_of_Tide[x].sW|= 0x8000;
  }
  Sp=max(1,3*My/Tv.mY);   // интервал между линиями профилей волн (Sp<0-отмена)
  Fy=( My+47 )/48;        // шаги прорисовки для векторов потоков и течений
  Fx=( Mx+15 )/16;
}
TWave::~TWave()             // проверка состоятельности
{ if( Active&as_Simula )    // всего блока численного моделирования
  { WaveIn_state( 0x80 );   // сброс мореографных установок в B_Mariom
        FreeTemp();         // Hf, Fa, _Fc, _Fs, _La
        Allocate( 0,0,Dp ); //
        Allocate( 0,0,Hg ); // все эти 4 массива всегда стоят на взводе
        Allocate( 0,0,Uy ); //
        Allocate( 0,0,Ux );
    if( Na>0 )Allocate( 0,Ma ); Map.view( Chart );
   void TideDataClose();
        TideDataClose(); Active&=~as_Simula; // Сброс моделирования
  }
}
//      Блок редактирования батиметрических данных и
//      гидродинамических полей (при необходимости)
//
static Real value( Real **_F,_Point P, int Ny,int Nx )
{
 Real dy,dx,dx1;                 //
 int y=(int)P.y,                 // Расчет индекса ближайшей точки
     x=(int)P.x;                 //  с последующей экстраполяцией на одну точку
  if( y<-1 || x<-1 || y>Ny || x>Nx )return 0.0;   // Расчет разностей аргумента
  if( x<0 )x=0; else if( x>=Nx-1 )x=Nx-2; dx=P.x-x,dx1=1-dx;
  if( y<0 )y=0; else if( y>=Ny-1 )y=Ny-2; dy=P.y-y; _F+=y;
 return ( _F[0][x]*dx1 + _F[0][x+1]*dx )*( 1-dy )
      + ( _F[1][x]*dx1 + _F[1][x+1]*dx )*dy;
}
void TWave::Edit_Chart()
{
 Depth Old_Depth=Chart; //
 Real **_F;             // Все
  Chart.edits();        // батиметрические массивы переочищаются в Depth::edits
  New_Initial();        // и собственно пересборка нового расчетного комплекса
  Thelp( "Поле уровней моря[%dx%d]",My,Mx );
  _F=(Real**)Allocate( My,size_t( Mx )*sizeof( Real ) );
#pragma omp parallel for
  for( int y=0; y<My; y++ )
  for( int x=0; x<Mx; x++ )
  { Point P={ x,y }; Chart.ItD( P ); Old_Depth.DtI( P ); // ??? замыкание
    _F[y][x]=value( Hg,P,Old_Depth.Ny,Old_Depth.Nx );  //     на сфере
  } Allocate( 0,0,Hg );
    Hg=_F;
  Thelp( "Поле.Y потоков[%dx%d]",My,Mx );
  _F=(Real**)Allocate( My,size_t( Mx )*sizeof( Real ) );
#pragma omp parallel for
  for( int y=0; y<My; y++ )
  for( int x=0; x<Mx; x++ )
  { Point P={ x,y }; Chart.ItD( P ); Old_Depth.DtI( P );
   _F[y][x]=value( Uy,P,Old_Depth.Ny,Old_Depth.Nx );
  } Allocate( 0,0,Uy );
    Uy=_F;
  Thelp( "Поле.X потоков[%dx%d]",My,Mx );
  _F=(Real**)Allocate( My,size_t( Mx )*sizeof( Real ) );
#pragma omp parallel for
  for( int y=1; y<My; y++ )
  for( int x=1; x<Mx; x++ )
  { Point P={ x,y }; Chart.ItD( P ); Old_Depth.DtI( P );
   _F[y][x]=value( Ux,P,Old_Depth.Ny,Old_Depth.Nx );
  } Allocate( 0,0,Ux );
    Ux=_F;
}
//
//   Определение расчетного интервала (шага) во Времени
//
void TWave::Time_Step()
{ Real d,C=0.0;
  for( int y=0; y<My; y++ )
  for( int x=0; x<Mx; x++ )if( (d=Dp[y][x])>0.0 )
  { if( WaveAs&0x0300 ){ Point P={ x,y }; Chart.ItD( P ); d/=sqr( cos( P.y/Radian ) ); }
    if( C<d )C=d;
  }
  if( WaveAs&0x0300 )C*=cos( Chart.Fe );
  Tstep = Dy*Dx/( hypot( Dy,Dx )*sqrt( C )*9.8106 );              // 80%
}
//
//      Настройка режимов вычислений и визуализации
//
int TWave::Initial_Mode_and_View( int ans )
{ const char
 *Name[]={ "Simulation","   Выполнение прямых        ",
                        "вычислительных экспериментов",
                        "  в гидродинамике океана",0 },
 *Text[]={ "F2 ","условия и режимы моделирования",
           "F3 ","определение внешних волн и приливов",
           "F4 ","установка геометрических источников",
           "F5 ","взаимодействие атмосферы и океана",
           "F6 ","корректировка или замена батиметрии",
           "F7 ","список сейсмических событий, цунами",
           "F8 ","подбор мореографных точек и постов",
           "F9 ","запуск процесса моделирования",0 },
 // ===================================================
 *sName[]={ "Service ","Определение условий проведения",
                       "вычислительного эксперимента,",
                       "установка режимов изображения",0 },
 *sText[]={ "F2 ","- перерисовка текущего изображения",
            "F3 ","определение внешних волн и приливов",
            "F4 ","установка геометрических источников",
            "F5 ","взаимодействие атмосферы и океана",
            "F6 ","корректировка или замена батиметрии",
            "F7 ","список сейсмических событий, цунами",
            "F8 ","подбор мореографных точек и постов",
            "F9 ","запуск процесса моделирования",0 },
 *sPlus[]={ "","  Если команда <Enter> выдана в окне: ",
            "Простой / Сфера+Вращение: ","выбор модели",
            "Трение: ","коэффициент придонной вязкости",
            "~~~~~~~~ Блок режимов экранной графики","",
            "Новые рисунки"," - отсчеты времени/шагов",
            "Профили волн ","- шаг и режимы 3D графики",
            "Уровни моря ","- контуры волн и раскраски",
            "Поток/течение ","поле потоков или течений",
            "+Метки+Числа < Море ","Методы регистрации",
            "<<Перезапуск>> ","интервал точек рестарта",
            " --<< Аппроксимационные критерии >>--","",
            "Период-Ячейки-Глубина  ","- допуски карты",
            "","из условий аппроксимационной гладкости",
            "- новая глубина ->"," перенос мореографов",
            "- ","радиус поиска изобаты по числу узлов",0 },
 *MSM[3]={ "\tПростые уравнения","\tСферическая Земля","\t+ вращение Земли" },
 *MSF[4]={ "\t& без уровней моря",
           "\t& изолинии уровней",
           "\t& объемная графика",
           "\t& графика и линии " };
 static short cmn=0;
    if( ans==0xF1 )ans=Help( Name,Text );
    if( ans!=0xF2 )return ans;         //
 static Real Cl=6.0,Tt=86400.0;       // Качество аппроксимации
 Display Tm( 0,0,1,1 );                //
 int   k,y,x,sp=12;                    // sp - дистанция для поиска изобаты
 Real  Dr=max( Dy,Dx ),C;              //
//byte& WaveI1=((byte*)(&WaveAs))[1];
  for( ;; )
  {
   const char M3[]=" ~~~~~~~~~~~~~~~~ ";
   Mlist Menu[]                                     //
   ={ { 0,18 },{ 1,1,"\t  Трение " },{ 0,0,0,&Kvs } // 0,1,2
    , { 1,0,M3 },{ 1,4,0,&St },{ 0,0 },{ 1,0 }      // 3,4,(5),6 - (5-свободна)
    , { 0,0,0,&Sp },{ 1,1,MSF[(VideoM>>2)&3] }      // 7,8
    , { 1,2,0,&Fy },{ 0,2,"x%-2d",&Fx  },{ 0,0,"" } // 9,10,11
    , { 1,6,(char*)(VideoM&0x2000 ? "\t+Метки":"\t-метки") }   // 12
    , { 0,6,(char*)(VideoM&0x4000 ? "\t+Числа":"\t-числа") }   // 13
    , { 0,3,(char*)(Dv<=0?"\t< Море":" > %.1lf"),Dv<=0?0:&Dv } // 14
    , { 1,1 }, { 0,0,0,&Rt }, { 1,0,"------------------" }     // 15,16,17
    , { 1,0,"\tВремя-Узлы-Глубина" },{ 1,6, "%6.1lf", &Tt }    // Ml-5
                                    ,{ 0,5," %5.1lf", &Cl }    // Ml-4
                                    ,{ 0,5," %5.2lf", &DZ }    // Ml-3
    , { 1,3,"\tЗа изобату %3d",&sp },{ 0,0,"\t узл" }          // Ml-1,2
    };                                                         //
   const int Ml=sizeof(Menu)/sizeof(Mlist);
    Tm.M = (mlist*)Menu;
    Tm.Nm=Ml;      Menu[0].Msg=MSM[((WaveAs&0x300)+0x100)>>9];
    if( WaveAs&0x400 )Menu[2].Msg=" %.5lf", Menu[2].lf=7,Menu[1].lf=0;
        else       Menu[2].Msg="\tснято   ",Menu[2].lf=0,Menu[1].lf=1;
     scpy( (char*)(Menu[3].Msg+10),ans?M3+1:DtoA( Tstep/3600,-3 ),7 );
    if( VideoM&1 ) Menu[4].Msg="\tКадры по часам%°";
        else       Menu[4].Msg="\tКадр по шагам %4.0lf";
                   Menu[6].Msg=(char*)(VideoM&0x40?"\tОбъемные волны:":"\tПрофили волн - ");
    if( Sp>0 )     Menu[7].Msg="%3d",   Menu[7].lf=3,Menu[6].lf=0;
        else       Menu[7].Msg="\tнет", Menu[7].lf=0,Menu[6].lf=1;
    if( Fx<0 )     Menu[9].Msg="\tПоля скоростей нет", Menu[9].dat=0,
                   Menu[10].Msg=0,Menu[11].Msg=0,Menu[10].lf=0; else
    if( VideoM&32 )Menu[9].Msg="\tПолный поток:%2d"; else
                   Menu[9].Msg="\tСкорость усл:%2d";
    if( Rt<=0.0 ){ Menu[15].Msg="\t << Перезапуск >> ",Menu[15].lf=1,
                   Menu[16].Msg="",                    Menu[16].lf=0; }
        else     { Menu[15].Msg="\t Перезапуск: ",     Menu[15].lf=0,
                   Menu[16].Msg="%2°",                 Menu[16].lf=5; }
    if( !Nmp )Tm.Nm-=2;
    Thelp( "F2 ReDraw  F3 Period  F4 Source  F5 Meteo  F6 Edit  F7 List"
         "  F8 Mario  F9 Start" ); color( LIGHTGRAY );
    Tt/=60; ans=Tm.Answer( cmn ); Tt*=60;
    if( VideoM&1 )
      { if( St<2.77778e-4 )St=2.77778e-4; else if( St>12 )St=12; }else
    if( St<=1 )St=1.0;   // Интервал обновления изображения
    if( Sp==0 )Sp=1;     // Пространственный шаг профилей волн
    if( Fx==0 )Fx=1;     // Шаг изображения векторов
    if( Fy<=0 )Fy=1;     //     течений или потоков
    if( Cl<1 )Cl=1.0;                                 //
    if( Tt<1 )Tt=1; C=DZ>=0.01?sqrt( DZ*9.8106 ):0.0; // 1cm
    switch( ans )                                     //
    { case 0: if( (WaveAs&0x100)==0 )WaveAs|=0x100; else // Тип проекции
              if( (WaveAs&0x200)==0 )WaveAs|=0x200; else //
                   WaveAs&=~0x300; Time_Step(); break;
      case 2:      ans=1;                             //
      case 1:      WaveAs^=0x400;            break;   // Вязкость
      case 16:                                        //
      case 15:   Rt=-Rt; ans=15;             break;   //
      case Ml-5: if( C>0.0 )Tt=Dr*Cl/C;      break;   // Калькулятор
      case Ml-4: if( C>0.0 )Cl=C*Tt/Dr;      break;   //  Dmih=F( T,Dr )
      case Ml-3: DZ=Dr*Cl/Tt; DZ*=DZ/9.8106; break;   //
      case Ml-2: Thelp( "Выполняется перенос %d мореографов"
                      " за изобату %3.1lf в радиусе %d узлов.",Nmp,DZ,sp );
                 for( k=0; k<Nmp; k++ )
                    Chart.move_to_coast( Mg[k],DZ,sp ); ans=0xF2; break;
      case 4: if( (VideoM^=1)&1 )St*=Tstep/3600.0;
                            else St/=Tstep/3600.0; Print_Time(); break;
//    case 5: Ghelp(); Tm.Back();
//            if( (VideoM^=0x80)&0x80 )setvisualpage( Chart.Egp^1 );
//            EGraph( true ); break;
      case 7: ans=6;                        // Профили волн
      case 6: if( Sp<0 ){ Sp=-Sp; VideoM|=0x40; } else
              if( VideoM&0x40 )VideoM^=0x40;      else Sp=-Sp; break;
      case 8: if( (VideoM&12)==12 )VideoM&=~12;
              else VideoM+=4; break;        // Контур-краска берега и волн
      case 10: ans=9;                       //
      case 9: if( Fx<=0 )VideoM|=32; else   // Векторное поле потоков
              if( VideoM&32 ){ VideoM&=~32; break; }
                   Fx=-Fx;     break;       //
      case 12: VideoM^=0x2000; break;       // Graphic
      case 13: VideoM^=0x4000; break;       // Values
      case 14: if( !Dv  )Dv=1; else Dv=-Dv; //
    }
    if( ans<Ml )cmn=ans;
    switch( ans )
    { case 0xF2: Ghelp(); Tm.Back(); EGraph( true );   break;
      case 0xF1:    ans=ans=Help( sName,sText,sPlus ); break;
      case _Esc:    ans=0;                goto Leave;
     default :  if( ans>0xF1 && ans<0xFA )goto Leave;
  } }
Leave:                                 //
  for( y=0; y<My; y++ )                // Расчистка гидродинамических полей
  for( x=0; x<Mx; x++ )                //  в области отсечения.
   if( Dp[y][x]<=DZ )                  //
     { Hg[y][x]=Uy[y][x]=Ux[y][x]=0.0; if( y<My-1 )Uy[y+1][x]=0.0;
                                       if( x<Mx-1 )Ux[y][x+1]=0.0;
     } return ans;
}
