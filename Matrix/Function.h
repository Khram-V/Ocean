//
//      Function.h                                                 /2008.11.09/
//      Программы построения простых функций
//
#ifndef __Function__
#define __Function__
#include <StdLib.h>
#include "..\Type.h"
//
//      Построение гладких числовых функций.
//      Функция может быть определена на конкретном массиве аргументов.
//      Если аргумент не задан, то им считается номер индекса точки
//            (т.е. - единичный шаг от 0 до length-1)
//
class Function            //
{ Real *_Y,*_X,*_2;       // Адреса массивов и производных в узлах интерполяции
  enum{ easy,first,spline } met;   // линия; 1-произв.в узлах; сплайн
  bool ext;                        // признак подключения внешних массивов
  int find( Real arg );            // поиск ближайшего левого  индекса
public:                            //
  size_t length;                   // Индексная длина линейного массива чисел
                              //===//
  Function& free();           //+ надо быть острожным, не удалять чужие массивы
  Function& set( size_t S );  //+ функция изначально задается с единичным шагом

  Real& Y( int k ){ return _Y[k]; }         // In/Out доступ к конкретной точке
  Real& X( int k );     // память для аргумента выделяется при первом обращении

 ~Function(){ free(); }                      // деструктор и много-много
  Function();                                // конструкторов
  Function( int S );                         // создание одного нового массива
  Function( Real *Y,Real *X );               // подключение функции и аргумента
  //
  //    Активизация различных режимов интерполяции
  //
  Function& SpLine( Real Yx1=1e32,   // Активизация Сплайн-интерполяции
                    Real YxN=1e32 ); // Производная в начале и в конце отрезка
  Function& First();                 // Расчет производных в узлах интерполяции
  Function& Easy(){ met=easy; return *this; } // возврат линейной интерполяции
  //
  //    Собственно интерполяция
  //    - оператор вычисляет значение функции в зависимости от контекстной
  //      настройки массивов и режимов функции
  //    - функции value и derivative срабатывают по тем же правилам при pw<0,
  //      иначе принудительно вменяется использование полинома степени pw>=0.
  //
  Real operator()( Real arg );       // интерполяция pw==1, или - указано met
  Real value( Real arg, int pw=-1 ); // полиномиальной интерполяции при pw>=0
  Real derivative ( Real arg, int pw=-1 ); // первая производная
  //
  //    Простое отключение внешних массивов ( !!! обязательно давать clear() )
  //
  Function& set( Real *Y );                              // простое присвоение
  Function& set( Real *Y, Real *X  ){ _X=X; return set( Y ); } // и отключение
  Function& clear(){ _Y=_X=NULL; return free(); }              // чужих данных
  //
  //    Инструментальные дополнения для связи с другими программами
  //
  void extrem( Real &xMin, Real &yMin, Real &xMax, Real &yMax );
};
#endif
