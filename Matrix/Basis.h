//
//     Basis.h                                   Ver 1.0  90.11.20
//
//     Процедуры построения альтернативного геометрического базиса
//          и базиса по четырехугольной деформированной площадке
//
//          ¦ xX  yX ¦         ¦ Xx  Yx ¦        Y   y         Def
//      M = ¦        ¦     m = ¦        ¦        л   л         --¬
//          ¦ xY  yY ¦         ¦ Xy  Yy ¦        ¦   ¦   A ¬a   -¦
//                                               ¦   ¦    /      v
//           -1   conjg( M )   ¦ yY -yX ¦        ¦   ¦   /
//      m = M   = ---------- = ¦        ¦ / ¦M¦  ¦   ¦  /
//                 det( M )    ¦-xY  xX ¦        ¦   ¦ r
//                                               ¦   +------------>x
//      A = Re + a • M                           ¦  Re
//      a = ( A-Re ) / M                         #==================>X
//
#ifndef _Basis_Hxx
#define _Basis_Hxx
#include "..\Type.h"
//
//      B A S I S - Определение локального базиса внутри глобального
//        Re      - координаты центра локального базиса
//        y,x     - определяющие векторы
//        size    - длины осей ортогонального базиса
//        angle   - ориентация меридиана (оси Y) в градусах
//
//      Axis( Re,y,x ) - Явное определение линейного базиса
//                       с помощью граничных векторов { y,x }
//      Decart( Re,x ) - Здесь вектор { x } задает не более чем направление,
//                       что исключает (смысл и) геометрические размерения
//                       для определяемого таким образом базиса
//      Euler( Re,angle,size ) - Географический базис заданный направлением и
//                       размерами прямоугольной области. Направление в °(гр)
//                       от северного меридиана, по ходу часовой стрелки
//      Area    Прямое определение по опорным точкам          c2
//      ( Aim - Результирующая прямоугольная площадка       Lu+  /
//        Crs - Тройка угловых точек, просматриваемых как:    ¦Crs
//      )     - на выходе площадь под угловыми точками      Ld+---+Rd
//        Ld  - перенос при сохранении деформации           Aim   c1
//        Ld,Rd - устанавливает ортогональную систему координат
//        Ld,Rd,Lu - это еще линейный базис
//        Ld,Rd,Lu,Ru - билинейный необратимый
//
struct Base                   // Линейные преобразования в единичном базисе
{ Point y,x,                  // Вид локального базиса в глобальных координатах
        Y,X;                  //  и отображение главных осей в локальном базисе
        Base(){ X=x=1; Y=y=~X; } // Собственно построение физического базиса
        Base(_Point U,_Point V ){ Axis( U,V ); } // Установка координатный осей
  Real  Axis(_Point U,_Point V )        //
  {           y=U,x=V;                  // Axis - определение локального базиса
   const Real det=y.y*x.x - y.x*x.y;    //      - обращение матрицы переходов
              Y.y=x.x/det,Y.x=-y.x/det; //
              X.x=y.y/det,X.y=-x.y/det; return det;
  }
 Point Goint( _Point A ){ return (Point){ A.x*X.x+A.y*Y.x,A.y*Y.y+A.x*X.y }; }
 Point Goext( _Point a ){ return (Point){ a.x*x.x+a.y*y.x,a.y*y.y+a.x*x.y }; }
};
class Basis: protected Base      // Точка отсчета и базисные оси
{ Point R;                       // Центр отсчета внешней системы координат
public: Basis():Base(){ R=0.0; } //   и единичный конструктор
  Real Axis(_Point Re,_Point _Y,_Point _X ){ R=Re; return Base::Axis(_Y,_X); };
  Real Euler(_Point Re,Real Angle,_Point Scl=(Point){1.0,1.0} ); // в Эйлеровом
//Real Decart( _Point Re,_Point x );                            // пространстве
  Point Goint( _Point A ){ return Base::Goint( A-R ); }  // к локальному базису
  Point Goext( _Point a ){ return Base::Goext( a )+R; }  // снова в глобальный
};
//    Установка прямоугольного окна Field B с билинейной подстройкой на Basis S
//         добавляется возможность деформации базиса, что          ( 93.11.23 )
//         нежелательно нагружать на простой исходный Basis.
//    Area                                                    Lu  Ru
//    ( Aim     - Результирующая прямоугольная площадка      3-----¬4
//      Corners - четыре угловых точки просматриваемых как:   ¦ Cs ¦
//    )         - на выходе площадь под угловыми точками     1L-----2
//                                                            Ld  Rd
//                                                        Aim
class Basis_Area: Basis  // НеЛинейные - с внутренними размерениями
{ Basis S;               // Встречный базис в противоположном углу
  Field B;               // Локальный Центр начала отсчета с размерами
  Real ky,kx;            // Деформация до произвольного четырехугольника
public: Basis_Area();
   Real Area( Field Aim, Point Ld,Point Rd );                   // lu+
   Real Area( Field Aim, Point Ld,Point Rd,Point Lu );          //   ¦Crs[3]
   Real Area( Field Aim, Point Ld,Point Rd,Point Lu,Point Ru ); // ld+--->rd
                         //
 Point Goint( Point A ); // Переход в локальный базис Aim
 Point Goext( Point a ); // Возврат в деформированный базис Crs
};
//  Поиск точки пересечения двух прямых L11-L12 и L21-L22,
//                          даже если таковые не особо сходятся
//
int Cross( Point L11, Point L12, Point L21, Point L22, Point& Cx );
//
//  Простая билинейная интерполяция по узлам матрицы с фиксированным шагом
//
Real Sleek( float *Y, Real X, int Nx );     // по целым узлам - по их номерам
Real Value( float **F, Real X,Real Y, int Nx,int Ny );
#endif
